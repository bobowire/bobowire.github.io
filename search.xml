<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>对指定IntPtr窗口截图（C#）</title>
      <link href="2020/12/29/%E5%AF%B9%E6%8C%87%E5%AE%9AIntPtr%E7%AA%97%E5%8F%A3%E6%88%AA%E5%9B%BE%EF%BC%88C-%EF%BC%89/"/>
      <url>2020/12/29/%E5%AF%B9%E6%8C%87%E5%AE%9AIntPtr%E7%AA%97%E5%8F%A3%E6%88%AA%E5%9B%BE%EF%BC%88C-%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>使用IntPtr方式对窗口截图，可以避免被其它窗体遮挡而影响截图效果的问题。</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li>通过Spy++或其他工具，获取指定窗口的IntPtr</li><li>调用CaptureWindow方法截图</li></ol><pre><code>public struct RECT    &#123;        public int Left;        public int Top;        public int Right;        public int Bottom;    &#125;    #region     enum GetWindowCmd : uint    &#123;        GW_HWNDFIRST = 0,        GW_HWNDLAST = 1,        GW_HWNDNEXT = 2,        GW_HWNDPREV = 3,        GW_OWNER = 4,        GW_CHILD = 5,        GW_ENABLEDPOPUP = 6    &#125;    #endregion    class ScreenCapture    &#123;        [DllImport(&quot;user32.dll&quot;)]        private static extern IntPtr GetWindowDC(IntPtr hwnd);        [DllImport(&quot;user32.dll&quot;)]        private static extern IntPtr GetForegroundWindow();        [DllImport(&quot;user32.dll&quot;)]        private static extern IntPtr GetWindowRect(IntPtr hWnd, out RECT rect);        [DllImport(&quot;user32.dll&quot;)]        private static extern bool PrintWindow(IntPtr hwnd, IntPtr hdcBlt, UInt32 nFlags);        [DllImport(&quot;user32.dll&quot;)]        private static extern IntPtr GetDesktopWindow();        [DllImport(&quot;user32.dll&quot;, SetLastError = true)]        static extern IntPtr GetWindow(IntPtr hWnd, GetWindowCmd uCmd);        [DllImport(&quot;gdi32.dll&quot;)]        private static extern IntPtr CreateDC(             string lpszDriver,         // driver name驱动名             string lpszDevice,         // device name设备名             string lpszOutput,         // not used; should be NULL             IntPtr lpInitData          // optional printer data         );        [DllImport(&quot;gdi32.dll&quot;)]        private static extern int BitBlt(             IntPtr hdcDest, // handle to destination DC目标设备的句柄             int nXDest,   // x-coord of destination upper-left corner目标对象的左上角的X坐标             int nYDest,   // y-coord of destination upper-left corner目标对象的左上角的Y坐标             int nWidth,   // width of destination rectangle目标对象的矩形宽度             int nHeight, // height of destination rectangle目标对象的矩形长度             IntPtr hdcSrc,   // handle to source DC源设备的句柄             int nXSrc,    // x-coordinate of source upper-left corner源对象的左上角的X坐标             int nYSrc,    // y-coordinate of source upper-left corner源对象的左上角的Y坐标             CopyPixelOperation dwRop   // raster operation code光栅的操作值         );        //static extern int BitBlt(IntPtr hdcDest, int xDest, int yDest, int        //wDest, int hDest, IntPtr hdcSource, int xSrc, int ySrc, CopyPixelOperation rop);        [DllImport(&quot;gdi32.dll&quot;)]        private static extern IntPtr CreateCompatibleDC(         IntPtr hdc // handle to DC         );        [DllImport(&quot;gdi32.dll&quot;)]        private static extern IntPtr CreateCompatibleBitmap(             IntPtr hdc,         // handle to DC             int nWidth,      // width of bitmap, in pixels             int nHeight      // height of bitmap, in pixels         );        [DllImport(&quot;gdi32.dll&quot;)]        private static extern IntPtr SelectObject(             IntPtr hdc,           // handle to DC             IntPtr hgdiobj    // handle to object         );        [DllImport(&quot;gdi32.dll&quot;)]        private static extern int DeleteDC(            IntPtr hdc           // handle to DC         );        [DllImport(&quot;user32.dll&quot;, SetLastError = true, CharSet = CharSet.Auto)]        static extern int GetClassName(IntPtr hWnd, StringBuilder lpClassName, int nMaxCount);        //[DllImport(&quot;User32.dll&quot;, CharSet = CharSet.Auto)]        //public static extern int GetClassName(IntPtr hWnd, out STRINGBUFFER ClassName, int nMaxCount);        public IntPtr GetFistChildHandle(IntPtr parent)        &#123;            return GetWindow(parent, GetWindowCmd.GW_CHILD);        &#125;        public IntPtr GetNextHandle(IntPtr ptr)        &#123;            return GetWindow(ptr, GetWindowCmd.GW_HWNDNEXT);        &#125;        public string GetClassName(IntPtr ptr)        &#123;            StringBuilder builder = new StringBuilder(20);            GetClassName(ptr, builder, 20);            return builder.ToString();        &#125;        public IntPtr FindHandleByClassName(IntPtr parent, string className)        &#123;            IntPtr childHandle = GetFistChildHandle(parent);            while (childHandle != IntPtr.Zero)            &#123;                string cName = GetClassName(childHandle);                if (cName.Trim().ToLower() == className.Trim().ToLower())                &#123;                    return childHandle;                &#125;                childHandle = GetNextHandle(childHandle);            &#125;            return IntPtr.Zero;        &#125;        /// &lt;summary&gt;        /// 抓取屏幕(层叠的窗口)        /// &lt;/summary&gt;        /// &lt;param name=&quot;x&quot;&gt;左上角的横坐标&lt;/param&gt;        /// &lt;param name=&quot;y&quot;&gt;左上角的纵坐标&lt;/param&gt;        /// &lt;param name=&quot;width&quot;&gt;抓取宽度&lt;/param&gt;        /// &lt;param name=&quot;height&quot;&gt;抓取高度&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        public Bitmap CaptureScreen(int x, int y, int width, int height)        &#123;            Bitmap bmp = new Bitmap(width, height);            using (Graphics g = Graphics.FromImage(bmp))            &#123;                g.CopyFromScreen(new Point(x, y), new Point(0, 0), bmp.Size);                g.Dispose();            &#125;            return bmp;        &#125;        /// &lt;summary&gt;        /// 指定窗口截图        /// &lt;/summary&gt;        /// &lt;param name=&quot;handle&quot;&gt;窗口句柄. (在windows应用程序中, 从Handle属性获得)&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        public Bitmap CaptureWindow(IntPtr hWnd)        &#123;            IntPtr hscrdc = GetWindowDC(hWnd);            RECT rect = new RECT();            return CaptureWindow(hWnd, rect);        &#125;        /// &lt;summary&gt;        /// 指定窗口区域截图        /// &lt;/summary&gt;        /// &lt;param name=&quot;handle&quot;&gt;窗口句柄. (在windows应用程序中, 从Handle属性获得)&lt;/param&gt;        /// &lt;param name=&quot;rect&quot;&gt;窗口中的一个区域&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        public Bitmap CaptureWindow(IntPtr hWnd, RECT rect)        &#123;            // 获取设备上下文环境句柄            IntPtr hscrdc = GetWindowDC(hWnd);            // 创建一个与指定设备兼容的内存设备上下文环境（DC）            IntPtr hmemdc = CreateCompatibleDC(hscrdc);            IntPtr myMemdc = CreateCompatibleDC(hscrdc);            // 返回指定窗体的矩形尺寸            RECT rect1;            GetWindowRect(hWnd, out rect1);            // 返回指定设备环境句柄对应的位图区域句柄            IntPtr hbitmap = CreateCompatibleBitmap(hscrdc, rect1.Right - rect1.Left, rect1.Bottom - rect1.Top);            IntPtr myBitmap = hbitmap;// CreateCompatibleBitmap(hscrdc, rect.Right - rect.Left, rect.Bottom - rect.Top);            //把位图选进内存DC             // IntPtr OldBitmap = (IntPtr)SelectObject(hmemdc, hbitmap);            SelectObject(hmemdc, hbitmap);            SelectObject(myMemdc, myBitmap);            /////////////////////////////////////////////////////////////////////////////            //            // 下面开始所谓的作画过程，此过程可以用的方法很多，看你怎么调用 API 了            //            /////////////////////////////////////////////////////////////////////////////            // 直接打印窗体到画布            PrintWindow(hWnd, hmemdc, 0);            // IntPtr hw = GetDesktopWindow();            // IntPtr hmemdcClone = GetWindowDC(myBitmap);            BitBlt(myMemdc, 0, 0, rect.Right - rect.Left, rect.Bottom - rect.Top, hmemdc, rect.Left, rect.Top, CopyPixelOperation.SourceCopy | CopyPixelOperation.CaptureBlt);            //SelectObject(myMemdc, myBitmap);            Bitmap bmp = Bitmap.FromHbitmap(myBitmap);            DeleteDC(hscrdc);            DeleteDC(hmemdc);            DeleteDC(myMemdc);            return bmp;        &#125;    &#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo基础命令</title>
      <link href="2020/12/29/Hexo%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
      <url>2020/12/29/Hexo%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><pre><code class="bash">$ hexo init [folder]</code></pre><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><p>This command is a shortcut that runs the following steps:</p><ol><li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> including <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> into the current directory or a target folder if specified.</li><li>Install dependencies using a package manager: <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>, <a href="https://pnpm.js.org/">pnpm</a> or <a href="https://docs.npmjs.com/cli/install">npm</a>, whichever is installed; if there are more than one installed, the priority is as listed. npm is bundled with <a href="/docs/#Install-Node-js">Node.js</a> by default.</li></ol><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><pre><code class="bash">$ hexo new [layout] &lt;title&gt;</code></pre><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="configuration.html">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><pre><code class="bash">$ hexo new &quot;post title with whitespace&quot;</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-p</code>, <code>--path</code></td><td>自定义新文章的路径</td></tr><tr><td><code>-r</code>, <code>--replace</code></td><td>如果存在同名文章，将其替换</td></tr><tr><td><code>-s</code>, <code>--slug</code></td><td>文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><pre><code class="bash">hexo new page --path about/me &quot;About me&quot;</code></pre><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><pre><code class="bash">hexo new page --path about/me</code></pre><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><pre><code class="bash">$ hexo generate</code></pre><p>生成静态文件。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-d</code>, <code>--deploy</code></td><td>文件生成后立即部署网站</td></tr><tr><td><code>-w</code>, <code>--watch</code></td><td>监视文件变动</td></tr><tr><td><code>-b</code>, <code>--bail</code></td><td>生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td><code>-f</code>, <code>--force</code></td><td>强制重新生成文件<br>Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。<br>使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td><code>-c</code>, <code>--concurrency</code></td><td>最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><pre><code class="bash">$ hexo g</code></pre><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><pre><code class="bash">$ hexo publish [layout] &lt;filename&gt;</code></pre><p>发表草稿。</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><pre><code class="bash">$ hexo server</code></pre><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-p</code>, <code>--port</code></td><td>重设端口</td></tr><tr><td><code>-s</code>, <code>--static</code></td><td>只使用静态文件</td></tr><tr><td><code>-l</code>, <code>--log</code></td><td>启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><pre><code class="bash">$ hexo deploy</code></pre><p>部署网站。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-g</code>, <code>--generate</code></td><td>部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><pre><code class="bash">$ hexo d</code></pre><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><pre><code class="bash">$ hexo render &lt;file1&gt; [file2] ...</code></pre><p>渲染文件。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-o</code>, <code>--output</code></td><td>设置输出路径</td></tr></tbody></table><h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><pre><code class="bash">$ hexo migrate &lt;type&gt;</code></pre><p>从其他博客系统 <a href="migration.html">迁移内容</a>。</p><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><pre><code class="bash">$ hexo clean</code></pre><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><pre><code class="bash">$ hexo list &lt;type&gt;</code></pre><p>列出网站资料。</p><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><pre><code class="bash">$ hexo version</code></pre><p>显示 Hexo 版本。</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><h3 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h3><pre><code class="bash">$ hexo --safe</code></pre><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><pre><code class="bash">$ hexo --debug</code></pre><p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href="https://github.com/hexojs/hexo/issues/new">提交调试信息到 GitHub</a>。</p><h3 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h3><pre><code class="bash">$ hexo --silent</code></pre><p>隐藏终端信息。</p><h3 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h3><pre><code class="bash"># 使用 custom.yml 代替默认的 _config.yml$ hexo server --config custom.yml# 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高$ hexo generate --config custom.yml,custom2.json,custom3.yml</code></pre><p>自定义配置文件的路径，指定这个参数后将不再使用默认的 <code>_config.yml</code>。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p><pre><code class="bash"># 使用 custom.yml 代替默认的 _config.yml$ hexo server --config custom.yml# 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json$ hexo generate --config custom.yml,custom2.json,custom3.yml</code></pre><p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p><h3 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h3><pre><code class="bash">$ hexo --draft</code></pre><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p><h3 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h3><pre><code class="bash">$ hexo --cwd /path/to/cwd</code></pre><p>自定义当前工作目录（Current working directory）的路径。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/09/26/hello-world/"/>
      <url>2020/09/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
